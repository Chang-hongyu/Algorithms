#广度优先搜索
##BFS算法
>1. BFS是基本的图算法之一，是很多图算法的原型，比如Prim最小生成树算法、Dijkstra单源最短路径算法等等。
>2. 给定图G=(V,E)和一个可以识别的源节点s，搜索从源节点s可以到达的所有节点，计算出从源节点到每个可到达的结点的距离，同时生成一颗广度优先搜索树，包含源节点s为根节点，包含所有可以从s到达的结点，且可以计算出s-v的最短路径。算法需要在发现所有距离为k的节点之后才会发现距离源节点为k+1的其他节点。
>3. BFS在概念上将结点涂上白色，灰色或者黑色，所有节点在一开始均涂上白色，发现节点之后变成灰色或者黑色。灰色节点的邻接节点中可能存在未被发现的白色节点，即灰色节点代表的是已知和未知两个集合之间的边界，黑的结点所有的邻接节点都已经被发现。下面是邻接链表所表示的BFS算法步骤

```
BFS(G,s)
1.	for each vertex u in G.V-{s}
2.		u.color = WHITE
3.		u.d = infty
4.		u.pi = NIL   #表示父节点
5.	s.color = GREY
6.	s.d = 0   #距离为0
7.	s.pi = NIL   #s即为根节点，无父节点
8.	Q = {}   #表示一个队列，用来管理灰色节点集合
9.	ENQUEUE(Q,S)
10.	while Q != {}:   #当不为空集时
11.		u = DEQUEUE(Q)
12.		for each v in D.adj[u]:
13.			if v.color = WHITE:
14.				v.color = GREY
15.				v.d = u.d + 1
16.				v.pi = u
17.				ENQUEUE(Q,v)
18.		u.color = BLACK   #当所有邻接节点遍历完之后，设置为黑色
```
>4.虽然BFS的结果依赖于每个结点的邻接结点的访问顺序，广度优先树可能不一样，但是算法所计算出来的距离d都是一样的。广度优先搜索的运行时间为O(E+V)，是邻接链表大小的一个线性函数。

##最短路径
>1. 最短路径为从节点s到节点v的所有路径中最少的边数，没有路径则为无穷大。最短路径有很多性质，参见算法导论p346-p347.

##广度优先树
在运行一个有向或者无向图G=(V,E)时，BFS所建造出来的pi属性，使得前驱子图Gpi = (Vpi,Epi)称为一颗广度优先树，而且树边数目 = 节点数目-1