#深度优先搜索
##基本内容
>1. DFS总是对最近才发现的结点v的出发边进行探索，直到该结点的所有出发边都被发现为止，一旦发现结点v的所有出发边，探索则回溯到v的前驱结点，来探索该前驱结点的出发边。一直持续到从源节点可以到达的所有结点都被发现未知。如果还存在着尚未发现的结点，则深度优先搜索将从这些未被发现的结点中任选一个作为新的源节点，并且重复同样的搜索过程。重复以上过程，直到图中所有结点都被发现为止。注意DFS和BFS的目的和结果不同(前者是发现所有结点，后者是发现所有从s可达的节点以及距离属性)
>2. 深度优先搜索的前驱子图可能由多颗树组成，而广度优先搜索的前驱子图形成一棵树，故对DFS的前驱子图的定义和BFS不同，具体参见书本。深度优先搜索的前驱子图形成一个由多颗深度优先树构成的深度优先森林，森林中的边依然为树边。
>3. DFS中，结点被发现之前的初始颜色为白色，在结点被发现后变为灰色，在其邻接链表被扫描完成之后变为黑色。该方法可以保证每个结点仅在一颗深度优先树中出现，所有的深度优先树是不相交的。DFS还在每个结点上盖上一个时间戳，v.d记录结点v第一次被发现的时间(涂上灰色的时间)，v.f记录搜索完成对v的邻接链表扫描的时间(涂上黑色的时间)。这些属性提供了图结构的重要信息，通常可以帮助推断深度优先搜索算法的行为。

```
DFS(G)
1.	for each vertex u in G.V:
2.		u.color = WHITE
3.		u.pi = NIL
4.	time = 0
5.	for each vertex u in G.V:
6.		if u.color == WHITE:
7.			DFS_VISIT(G,u)

DFS_VISIT(G,u)
1.	time = time + 1
2.	u.d = time
3.	u.color = GREY
4.	for each vertex v in G:Adj[u]:
5.		if v.color == WHITE:
6.			v.pi = u
7.			DFS_VISIT(G,v)
8.	u.color = BLACK
9.	time = time + 1
10.	u.f = time
```
>4.算法的运行时间为O(V+E)

##深度优先搜索树的性质
>1. 深度优先树的结构与DFS-VISIT的递归调用结构完全对应，即u=v.pi当且仅当DFS—VISIT(G,v)在算法对u的邻接链表进行搜索时被调用。此外，节点v是深度优先森林里结点u的后代当且仅当结点v在结点u为灰色的时间段里被发现。
>2. 结点的发现时间和完成时间具有所谓的括号化结构。
>3. 白色路径定理：在有向或者无向图G=(V,E)的深度优先森林中，节点v是节点u的后代，当且仅当在发现节点u的时间u.d时，存在一条从节点u到节点v的全部由白色结点所构成的路径。

## 边的分类
每条边的类型可以提供关于图的重要信息。例如，有向图是无向图当且仅当**深度优先搜索不产生后向边**。
>1. 树边：为深度优先森林Gpi中的边，在图中表示为深阴影部分。如果节点v是因算法对边(u,v)的探索而首先被发现，则(u,v)是一条树边。
>2. 后向边：后向边(u,v)是将节点u连接到其在深度优先树中一个祖先节点v的边，由于有向图中可以存在自循环，自循环也可以被认为是后向边。
>3. 前向边：是将结点u连接到其在深度优先树种一个后代结点v的边。
>4. 横向边：指其他所有的边，这些边可以连接同一颗深度优先树中的结点，只要其中一个结点不是另外一个结点的祖先，也可以连接不同深度优先树中的两个结点。

可以对原始图进行重画，以便让所有的树边和前向边都朝下指，而所有的前向边都朝上指。当第一次探索到边(u,v)时，节点v的颜色可以告知我们关于这条边的一些信息。
>1. 节点v为白色，表示边(u,v)是一条树边
>2. 节点v为灰色，表示边(u,v)是一条后向边。
>3. 节点v为黑色，表示边(u,v)是一条前向边或者横向边

而在对无向图的深度优先搜索中，从来不会出现前向边或者横向边，即：每条边要么是树边，要么是后向边。因为递归前的循环，会对所有的连接节点进行分别得查找递归，所以不会出现前向边或者横向边。