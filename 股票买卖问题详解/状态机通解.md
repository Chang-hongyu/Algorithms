##本篇文档给出股票买卖问题的优化通解，可以在0(N)内求解
我们以第四题为例，对所有情况进行分析，我们对状态进行穷举，穷举的目的是利用状态进行穷举

>1.具体到每个问题，每天都有三种操作，即三种选择：买入、卖出和无操作，我们用buy,sell和rest来表示这三种操作。注意这三种操作并不是刻意随意选择的，sell必须在buy之后，buy必须在sell之后(第一次除外)。rest操作还分为两种状态，一种是buy之后的rest(持有了股票)，一种是sell了之后的rest(没有持有股票)。此外我们还有交易次数k的限制，即在buy操作的同时必须保证k>0的前提下操作。

>2.我们将这个问题的操作设为3个，即dp[i][j][k]，其中**i代表天数，j代表当天允许交易的最大次数，k代表当前的持有状态(即rest，1表示持有，0表示没有持有)**。

>>>说明(1)：dp[i][j][0 or 1]，其中0<=i<=n-1, 1<=k<=K, n为天数，K为最大允许交易天数，此问题共nxKx2种状态，穷举可以全部搞定

```python
for 0<=i<=n-1:
	for 1<=k<=K:
		for s in {0,1}:
			dp[i][k][s] = max(buy,sell,rest)
```
>>>说明(2)：比如dp[3][2][1]的含义是今天是第三天，我现在手里持有着股票，至今至多进行2次交易。dp[2][3][0]的含义是：今天是第2天，我现在手里没有持有股票，至今至多进行3次交易。我们最终想求的答案是dp[n-1][K][0],即为最后一天，最多允许K次交易，最后一天手里不持有股票，所能获得的最大利润。

>3.关键点在于，如何根据我们的选择buy,sell,rest来更新状态，我们来写一下状态转移方程：
	
	对于第i天的操作 k以买入次数为基准来衡量
	dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
				  max(对应第i天选择rest, 对应第i天选择卖出)
	dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
				  max(对应第i天选择rest, 对应第i天选择买入(需要将k加1))
	
	此外的关键是base case的定义：
	dp[-1][k][0] = 0, i=-1对应还没开始，利润为0
	dp[-1][k][1] = -inf, 还没开始时不可能持有股票，负无穷表示不可能情形
	dp[i][0][0] = 0, k是从1开始的，k为0表示根本不允许交易，所以这时候利润当然为0
	dp[i][0][1] = -inf, 不允许交易的情况下，不可能持有股票，负无穷表示这种情况是不可能的
	
	总结一下即：
		dp[-1][k][0] = dp[i][0][0] = 0
		dp[-1][k][1] = dp[i][0][1] = -inf
		dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
		dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])

>4.套用上述公式，可以对各个题目进行求解，对于股票交易题目1，只允许交易一次那么有

```python
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1]+prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0]-prices[i])=max(dp[i-1][1][1], -prices[i])
发现k都是1，那么k对状态转移没用了，可以简化：
dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])

直接翻译成代码 见代码stock_1.py
```

>5.对于第2题，如果k为正无穷，那么可以认为k和k-1是一样的，可以这样改写框架：
	
	dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
	dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i])
				= max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])
	我们发现数组中的k已经不会变化了，也就是说不需要记录k这个状态了
	dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
	dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
	可以直接翻译成代码 见代码stock_2.py
	
>6.对于第3题，我们限定最大交易次数为2，这种情况其实比1，2，5，6都更加复杂，K的影响更重要，这时对K的处理重要性就凸显出来了，我们分析状态转移关系，边分析边进行推导：

	我们有原始的状态转移方程，没有可以简化的地方：
	dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
	dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
	这里的边界条件比较多，我们手动把k=1和2的情况列举出来
	dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
	dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i]）
	dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
	dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])
				= max(dp[i-1][1][1], -prices[i])
	我们将上述转化为代码 见stock_3.py

>7.这里我们允许进行K次交易，但是注意K太大时，导致dp数组太大，会超时超内存，所以我们考虑k不应该超过n//2

	如果K > N//2，那么我们限制 K==n//2，递归调用代码。
	剩余部分就调用上一题代码，
	代码参考stock_4.py

>8.对于第五题，不限交易次数，但是卖出的第一天不能买入，必须等待一天的冷却期，考虑新的状态转移方程：

	dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
	dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
	注意事项：第i天选择买入的时候，要从i-2状态转移，而不是i-1
	直接翻译成代码 见 stock_cooldown.py

>9.对于第9题，不限交易次数，但是每次交易必须付出一定的手续费。考虑下面状态转移方程：

	每次需要交手续费，则将手续费从利润中减去即可：
	dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
	dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
	这样处理，相当于买入股票的价格升高了，在第一个式子里减去也可以，相当于卖出股票的价格减小了。即：
	dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)
	dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
	
**至此，状态机解法已经全部给出，后续还需多看多多巩固**